This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
src/
  maskilayer/
    __init__.py
    __main__.py
    maskilayer.py
tests/
  conftest.py
.coveragerc
.gitignore
.isort.cfg
.pre-commit-config.yaml
AUTHORS.md
CHANGELOG.md
CONTRIBUTING.md
LICENSE.txt
pyproject.toml
README.md
setup.cfg
setup.py
tox.ini
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: Python package CI

on:
  push:
    branches: [main]
    tags: ['v*']
  pull_request:
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.11', '3.12']
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install fire pytest
    - name: Run tests
      run: |
        python -m pip install -e .

  publish:
    needs: build-and-test
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    - name: Build and publish
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_TOKEN }}
      run: |
        python -m pip install --upgrade build twine
        python -m build
        twine upload dist/*
</file>

<file path="src/maskilayer/__init__.py">
import sys

if sys.version_info[:2] >= (3, 11):
    from importlib.metadata import PackageNotFoundError, version  # pragma: no cover

try:
    # Change here if project is renamed and does not equal the package name
    dist_name = __name__
    __version__ = version(dist_name)
except PackageNotFoundError:  # pragma: no cover
    __version__ = "unknown"
finally:
    del version, PackageNotFoundError
</file>

<file path="src/maskilayer/__main__.py">
#!/usr/bin/env python3

from pathlib import Path

import fire
from rich.console import Console

from .maskilayer import comp_images, normalize_paths


def cli_help():
    fire.Fire(main, command=["--help"])


def main(
    back: str = "",
    comp: str = "",
    out: str = "",
    smask: str = "",
    masks: str | None = None,
    imasks: str | None = None,
    norm: int = 0,
    verbose: bool = False,
    fast: bool = False,
) -> None:
    """
    Composite two images using mask(s).

    Args:
        back: layer 0 (background image path)
        comp: layer 1 (overlay image path that will be composited via masks)
        out: output composite image
        smask: path to save the final mask (optional)
        masks: ;-separated mask image paths (optional)
        imasks: ;-separated negative mask image paths (optional)
        norm: perform mask normalization with level 0-5
        verbose: print additional output
        fast: save fast but larger files
    """
    if back:
        back = Path(back)
    else:
        cli_help()
    if comp:
        comp = Path(comp)
    else:
        cli_help()
    if out:
        out = Path(out)
    else:
        cli_help()
    if smask:
        smask = Path(smask)
    else:
        smask = None
    comp_images(
        background=back,
        overlay=comp,
        output=out,
        masks=normalize_paths(masks),
        invert_masks=normalize_paths(imasks),
        save_mask=Path(smask),
        normalize_level=int(norm),
        verbose=verbose,
        fast=fast,
    )


def cli():
    console = Console(highlight=False, markup=True)
    fire.core.Display = lambda lines, out: console.print(*lines)
    fire.Fire(main)


if __name__ == "__main__":
    cli()
</file>

<file path="src/maskilayer/maskilayer.py">
#!/usr/bin/env python3
"""
Image compositing tool using numpy and PIL.
"""

import asyncio
import io
import logging
from pathlib import Path
from typing import Sequence

import aiofiles
import numpy as np
from PIL import Image
from rich.logging import RichHandler

logger = logging.getLogger(__name__)


def setup_logging(verbose: bool) -> None:
    """Configure logging using rich."""
    level = logging.INFO if verbose else logging.WARN
    logging.basicConfig(
        level=level,
        format="%(message)s",
        handlers=[RichHandler(rich_tracebacks=True)],
    )


def log(msg: str, indent: int = 0):
    if indent == 0:
        msg = f"[green]{msg}[/]"
    else:
        msg = f"""{" " * indent * 2}{msg}"""
    logger.info(msg, extra={"markup": True})


def arr_from_layer(path: Path, idx: int = 0) -> np.ndarray:
    """Load an image from path into a numpy array."""
    log(f"Opening layer {idx}: [blue]{path}[/]", 1)
    return np.array(Image.open(path))


def arr_from_mask(path: Path, idx: int = 0) -> np.ndarray:
    """Load a mask image into a float numpy array."""
    log(f"Opening mask {idx}:  [blue]{path}[/]", 1)
    return np.array(Image.open(path).convert("L")).astype(float) / 255.0


def normalize_mask_arr(mask: np.ndarray, level: float, idx: int = 0) -> np.ndarray:
    """
    Normalize a mask array.

    Args:
        mask (np.ndarray): The input mask array.
        level (float): Normalization level between 0 and 3.

    Returns:
        np.ndarray: The normalized mask array.
    """
    if level <= 0:
        return mask

    log(f"Normalizing mask {idx} level [blue]{level}[/]", 1)

    # Normalize min to 0, max to 1
    mask_min, mask_max = mask.min(), mask.max()
    log(f"Mask {idx} found range: [blue]{mask_min:.2f} - {mask_max:.2f}[/]", 2)

    mask = (mask - mask_min) / (mask_max - mask_min)

    if level == 1:
        return mask

    # Truncate by luminance cutoff
    cutoff = 0.5 - 0.25 * np.exp(-(level - 2) * 0.5)
    log(f"Mask {idx} luminance: [blue]{cutoff:.2f}[/]", 2)

    mask = np.clip(mask, cutoff, 1 - cutoff)
    mask = (mask - cutoff) / (1 - 2 * cutoff)

    # Apply gamma correction
    gamma = 1.0 - 0.75 * (1 - np.exp(-(level - 1) * 2.0))
    log(f"Mask {idx} gamma: [blue]{gamma:.2f}[/]", 2)

    mask = np.power(mask, gamma)

    # Normalize again
    mask_min, mask_max = mask.min(), mask.max()
    log(f"Mask {idx} final range: [blue]{mask_min:.2f} - {mask_max:.2f}[/]", 2)

    mask = (mask - mask_min) / (mask_max - mask_min)

    return mask


def composite_arrs(
    background: np.ndarray,
    overlay: np.ndarray,
    mask: np.ndarray,
) -> np.ndarray:
    """
    Composite an overlay image onto a background using a mask.

    Args:
        background (np.ndarray): The background image array.
        overlay (np.ndarray): The overlay image array.
        mask (np.ndarray): The compositing mask array.

    Returns:
        np.ndarray: The composite image array.
    """
    log("Compositing layers")
    return background * (1 - mask[..., np.newaxis]) + overlay * mask[..., np.newaxis]


def blend_mask_arrs(masks: Sequence[np.ndarray]) -> np.ndarray:
    """
    Blend multiple mask arrays by averaging.

    Args:
        masks (Sequence[np.ndarray]): The input mask arrays.

    Returns:
        np.ndarray: The blended mask array.
    """
    log(f"Blending {len(masks)} masks")
    return np.mean(masks, axis=0)


async def write_image(image: Image.Image, path: Path, fast: bool = False) -> None:
    """
    Write an image to a file asynchronously.

    Args:
        image (Image.Image): The image to write.
        path (Path): The output file path.
        fast (bool): Whether to optimize for speed vs size. Defaults to False.
    """
    log(f"Saving image: [blue]{path}[/]", 1)
    output = io.BytesIO()

    if fast:
        image.save(output, format="PNG", optimize=False, compress_level=0)
    else:
        image.save(output, format="PNG", optimize=True)

    path.parent.mkdir(parents=True, exist_ok=True)

    output.seek(0)
    async with aiofiles.open(path, "wb") as f:
        await f.write(output.getvalue())


async def write_images(images: Sequence[tuple[Image.Image, Path, bool]]) -> None:
    """
    Write multiple images concurrently.

    Args:
        images (Sequence[tuple[Image.Image, Path, bool]]): Images to write.
    """
    await asyncio.gather(*[write_image(img, path, fast) for img, path, fast in images])


def normalize_paths(
    paths: str | Path | Sequence[str | Path] | None = None,
) -> Sequence[Path]:
    if not paths:
        return []

    if isinstance(paths, str):
        if ";" in paths:
            paths = [Path(p) for p in paths.split(";")]
        elif "," in paths:
            paths = [Path(p) for p in paths.split(",")]
        else:
            paths = [Path(paths)]
    elif isinstance(paths, Path):
        paths = [paths]

    return [p for p in paths if Path(p).is_file()]


def check_arrs_dim(arrays: Sequence[np.ndarray]) -> None:
    """
    Check that all arrays have the same dimensions.

    Args:
        arrays (Sequence[np.ndarray]): Input arrays.

    Raises:
        ValueError: If the array dimensions don't match.
    """
    if not arrays:
        return

    reference = arrays[0].shape[:2]

    for array in arrays[1:]:
        if array.shape[:2] != reference:
            raise ValueError(
                f"Input array dimensions must match, got {array.shape[:2]} and {reference}"
            )


def comp_images(
    background: Path | None = None,
    overlay: Path | None = None,
    output: Path | None = None,
    masks: Sequence[Path] = [],
    invert_masks: Sequence[Path] = [],
    save_mask: Path | None = None,
    normalize_level: int = 0,
    verbose: bool = False,
    fast: bool = False,
) -> None:
    setup_logging(verbose)
    log("Opening layers")
    background_arr = arr_from_layer(Path(background), 0)
    overlay_arr = arr_from_layer(Path(overlay), 1)

    log("Opening positive masks")
    mask_paths = normalize_paths(masks)
    mask_arrs = [arr_from_mask(p, pi) for pi, p in enumerate(mask_paths)]

    log("Opening negative masks")
    invert_mask_paths = normalize_paths(invert_masks)
    invert_mask_arrs = [
        1 - arr_from_mask(p, pi + len(mask_arrs))
        for pi, p in enumerate(invert_mask_paths)
    ]
    mask_arrs.extend(invert_mask_arrs)

    check_arrs_dim([background_arr, overlay_arr] + mask_arrs)

    if not mask_arrs:
        log("Will composite at 50%")
        mask_arr = np.full(background_arr.shape[:2], 0.5)
    else:
        log("Normalizing masks")
        mask_arrs = [
            normalize_mask_arr(m, normalize_level, mi) for mi, m in enumerate(mask_arrs)
        ]
        mask_arr = blend_mask_arrs(mask_arrs)

    composite = composite_arrs(background_arr, overlay_arr, mask_arr)

    writes = []

    if save_mask:
        mask_img = Image.fromarray((mask_arr * 255).astype(np.uint8))
        writes.append((mask_img, Path(save_mask), fast))

    composite_img = Image.fromarray(composite.astype(np.uint8))
    writes.append((composite_img, Path(output), fast))

    log("Saving outputs")
    asyncio.run(write_images(writes))
    log("Finished")
</file>

<file path="tests/conftest.py">
"""
    Dummy conftest.py for maskilayer.

    If you don't know what this is for, just leave it empty.
    Read more about conftest.py under:
    - https://docs.pytest.org/en/stable/fixture.html
    - https://docs.pytest.org/en/stable/writing_plugins.html
"""

# import pytest
</file>

<file path=".coveragerc">
# .coveragerc to control coverage.py
[run]
branch = True
source = maskilayer
# omit = bad_file.py

[paths]
source =
    src/
    */site-packages/

[report]
# Regexes for lines to exclude from consideration
exclude_lines =
    # Have to re-enable the standard pragma
    pragma: no cover

    # Don't complain about missing debug-only code:
    def __repr__
    if self\.debug

    # Don't complain if tests don't hit defensive assertion code:
    raise AssertionError
    raise NotImplementedError

    # Don't complain if non-runnable code isn't run:
    if 0:
    if __name__ == .__main__.:
</file>

<file path=".gitignore">
# Temporary and binary files
*~
*.py[cod]
*.so
*.cfg
!.isort.cfg
!setup.cfg
*.orig
*.log
*.pot
__pycache__/*
.cache/*
.*.swp
*/.ipynb_checkpoints/*
.DS_Store

# Project files
.ropeproject
.project
.pydevproject
.settings
.idea
.vscode
tags

# Package files
*.egg
*.eggs/
.installed.cfg
*.egg-info

# Unittest and coverage
htmlcov/*
.coverage
.coverage.*
.tox
junit*.xml
coverage.xml
.pytest_cache/

# Build and docs folder/files
build/*
dist/*
sdist/*
docs/api/*
docs/_rst/*
docs/_build/*
cover/*
MANIFEST

# Per-project virtualenvs
.venv*/
.conda*/
.python-version


# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
.python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
.idea/

# VS Code
.vscode/

# macOS
.DS_Store

# Project-specific
output_images/
temp/
</file>

<file path=".isort.cfg">
[settings]
profile = black
known_first_party = maskilayer
</file>

<file path=".pre-commit-config.yaml">
exclude: '^docs/conf.py'

repos:
- repo: https://github.com/pre-commit/pre-commit-hooks
  rev: v4.6.0
  hooks:
  - id: trailing-whitespace
  - id: check-added-large-files
  - id: check-ast
  - id: check-json
  - id: check-merge-conflict
  - id: check-xml
  - id: check-yaml
  - id: debug-statements
  - id: end-of-file-fixer
  - id: requirements-txt-fixer
  - id: mixed-line-ending
    args: ['--fix=auto']  # replace 'auto' with 'lf' to enforce Linux/Mac line endings or 'crlf' for Windows

## If you want to automatically "modernize" your Python code:
# - repo: https://github.com/asottile/pyupgrade
#   rev: v3.7.0
#   hooks:
#   - id: pyupgrade
#     args: ['--py37-plus']

## If you want to avoid flake8 errors due to unused vars or imports:
# - repo: https://github.com/PyCQA/autoflake
#   rev: v2.1.1
#   hooks:
#   - id: autoflake
#     args: [
#       --in-place,
#       --remove-all-unused-imports,
#       --remove-unused-variables,
#     ]

- repo: https://github.com/PyCQA/isort
  rev: 5.13.2
  hooks:
  - id: isort

- repo: https://github.com/psf/black
  rev: 24.4.2
  hooks:
  - id: black
    language_version: python3

## If like to embrace black styles even in the docs:
# - repo: https://github.com/asottile/blacken-docs
#   rev: v1.13.0
#   hooks:
#   - id: blacken-docs
#     additional_dependencies: [black]

- repo: https://github.com/PyCQA/flake8
  rev: 7.1.0
  hooks:
  - id: flake8
  ## You can add flake8 plugins via `additional_dependencies`:
  #  additional_dependencies: [flake8-bugbear]

## Check for misspells in documentation files:
# - repo: https://github.com/codespell-project/codespell
#   rev: v2.2.5
#   hooks:
#   - id: codespell
</file>

<file path="AUTHORS.md">
# Contributors

* Adam Twardoch <adam+github@twardoch.com>
</file>

<file path="CHANGELOG.md">
# Changelog

## Version 0.1.0 (2024-06-24)

- Initial release
- Implemented basic image compositing functionality
- Added support for multiple masks and inverted masks
- Implemented mask normalization with adjustable levels
- Added asynchronous image writing
- Created command-line interface
</file>

<file path="CONTRIBUTING.md">
```{todo} THIS IS SUPPOSED TO BE AN EXAMPLE. MODIFY IT ACCORDING TO YOUR NEEDS!

   The document assumes you are using a source repository service that promotes a
   contribution model similar to [GitHub's fork and pull request workflow].
   While this is true for the majority of services (like GitHub, GitLab,
   BitBucket), it might not be the case for private repositories (e.g., when
   using Gerrit).

   Also notice that the code examples might refer to GitHub URLs or the text
   might use GitHub specific terminology (e.g., *Pull Request* instead of *Merge
   Request*).

   Please make sure to check the document having these assumptions in mind
   and update things accordingly.
```

```{todo} Provide the correct links/replacements at the bottom of the document.
```

```{todo} You might want to have a look on [PyScaffold's contributor's guide],

   especially if your project is open source. The text should be very similar to
   this template, but there are a few extra contents that you might decide to
   also include, like mentioning labels of your issue tracker or automated
   releases.
```

# Contributing

Welcome to `maskilayer` contributor's guide.

This document focuses on getting any potential contributor familiarized with
the development processes, but [other kinds of contributions] are also appreciated.

If you are new to using [git] or have never collaborated in a project previously,
please have a look at [contribution-guide.org]. Other resources are also
listed in the excellent [guide created by FreeCodeCamp] [^contrib1].

Please notice, all users and contributors are expected to be **open,
considerate, reasonable, and respectful**. When in doubt,
[Python Software Foundation's Code of Conduct] is a good reference in terms of
behavior guidelines.

## Issue Reports

If you experience bugs or general issues with `maskilayer`, please have a look
on the [issue tracker].
If you don't see anything useful there, please feel free to fire an issue report.

:::{tip}
Please don't forget to include the closed issues in your search.
Sometimes a solution was already reported, and the problem is considered
**solved**.
:::

New issue reports should include information about your programming environment
(e.g., operating system, Python version) and steps to reproduce the problem.
Please try also to simplify the reproduction steps to a very minimal example
that still illustrates the problem you are facing. By removing other factors,
you help us to identify the root cause of the issue.

## Documentation Improvements

You can help improve `maskilayer` docs by making them more readable and coherent, or
by adding missing information and correcting mistakes.

`maskilayer` documentation uses [Sphinx] as its main documentation compiler.
This means that the docs are kept in the same repository as the project code, and
that any documentation update is done in the same way was a code contribution.

```{todo} Don't forget to mention which markup language you are using.

    e.g.,  [reStructuredText] or [CommonMark] with [MyST] extensions.
```

```{todo} If your project is hosted on GitHub, you can also mention the following tip:

   :::{tip}
      Please notice that the [GitHub web interface] provides a quick way of
      propose changes in `maskilayer`'s files. While this mechanism can
      be tricky for normal code contributions, it works perfectly fine for
      contributing to the docs, and can be quite handy.

      If you are interested in trying this method out, please navigate to
      the `docs` folder in the source [repository], find which file you
      would like to propose changes and click in the little pencil icon at the
      top, to open [GitHub's code editor]. Once you finish editing the file,
      please write a message in the form at the bottom of the page describing
      which changes have you made and what are the motivations behind them and
      submit your proposal.
   :::
```

When working on documentation changes in your local machine, you can
compile them using [tox] :

```
tox -e docs
```

and use Python's built-in web server for a preview in your web browser
(`http://localhost:8000`):

```
python3 -m http.server --directory 'docs/_build/html'
```

## Code Contributions

```{todo} Please include a reference or explanation about the internals of the project.

   An architecture description, design principles or at least a summary of the
   main concepts will make it easy for potential contributors to get started
   quickly.
```

### Submit an issue

Before you work on any non-trivial code contribution it's best to first create
a report in the [issue tracker] to start a discussion on the subject.
This often provides additional considerations and avoids unnecessary work.

### Create an environment

Before you start coding, we recommend creating an isolated [virtual environment]
to avoid any problems with your installed Python packages.
This can easily be done via either [virtualenv]:

```
virtualenv <PATH TO VENV>
source <PATH TO VENV>/bin/activate
```

or [Miniconda]:

```
conda create -n maskilayer python=3 six virtualenv pytest pytest-cov
conda activate maskilayer
```

### Clone the repository

1. Create an user account on GitHub if you do not already have one.

2. Fork the project [repository]: click on the *Fork* button near the top of the
   page. This creates a copy of the code under your account on GitHub.

3. Clone this copy to your local disk:

   ```
   git clone git@github.com:YourLogin/maskilayer.git
   cd maskilayer
   ```

4. You should run:

   ```
   pip install -U pip setuptools -e .
   ```

   to be able to import the package under development in the Python REPL.

   ```{todo} if you are not using pre-commit, please remove the following item:
   ```

5. Install [pre-commit]:

   ```
   pip install pre-commit
   pre-commit install
   ```

   `maskilayer` comes with a lot of hooks configured to automatically help the
   developer to check the code being written.

### Implement your changes

1. Create a branch to hold your changes:

   ```
   git checkout -b my-feature
   ```

   and start making changes. Never work on the main branch!

2. Start your work on this branch. Don't forget to add [docstrings] to new
   functions, modules and classes, especially if they are part of public APIs.

3. Add yourself to the list of contributors in `AUTHORS.rst`.

4. When youâ€™re done editing, do:

   ```
   git add <MODIFIED FILES>
   git commit
   ```

   to record your changes in [git].

   ```{todo} if you are not using pre-commit, please remove the following item:
   ```

   Please make sure to see the validation messages from [pre-commit] and fix
   any eventual issues.
   This should automatically use [flake8]/[black] to check/fix the code style
   in a way that is compatible with the project.

   :::{important}
   Don't forget to add unit tests and documentation in case your
   contribution adds an additional feature and is not just a bugfix.

   Moreover, writing a [descriptive commit message] is highly recommended.
   In case of doubt, you can check the commit history with:

   ```
   git log --graph --decorate --pretty=oneline --abbrev-commit --all
   ```

   to look for recurring communication patterns.
   :::

5. Please check that your changes don't break any unit tests with:

   ```
   tox
   ```

   (after having installed [tox] with `pip install tox` or `pipx`).

   You can also use [tox] to run several other pre-configured tasks in the
   repository. Try `tox -av` to see a list of the available checks.

### Submit your contribution

1. If everything works fine, push your local branch to the remote server with:

   ```
   git push -u origin my-feature
   ```

2. Go to the web page of your fork and click "Create pull request"
   to send your changes for review.

   ```{todo} if you are using GitHub, you can uncomment the following paragraph

      Find more detailed information in [creating a PR]. You might also want to open
      the PR as a draft first and mark it as ready for review after the feedbacks
      from the continuous integration (CI) system or any required fixes.

   ```

### Troubleshooting

The following tips can be used when facing problems to build or test the
package:

1. Make sure to fetch all the tags from the upstream [repository].
   The command `git describe --abbrev=0 --tags` should return the version you
   are expecting. If you are trying to run CI scripts in a fork repository,
   make sure to push all the tags.
   You can also try to remove all the egg files or the complete egg folder, i.e.,
   `.eggs`, as well as the `*.egg-info` folders in the `src` folder or
   potentially in the root of your project.

2. Sometimes [tox] misses out when new dependencies are added, especially to
   `setup.cfg` and `docs/requirements.txt`. If you find any problems with
   missing dependencies when running a command with [tox], try to recreate the
   `tox` environment using the `-r` flag. For example, instead of:

   ```
   tox -e docs
   ```

   Try running:

   ```
   tox -r -e docs
   ```

3. Make sure to have a reliable [tox] installation that uses the correct
   Python version (e.g., 3.7+). When in doubt you can run:

   ```
   tox --version
   # OR
   which tox
   ```

   If you have trouble and are seeing weird errors upon running [tox], you can
   also try to create a dedicated [virtual environment] with a [tox] binary
   freshly installed. For example:

   ```
   virtualenv .venv
   source .venv/bin/activate
   .venv/bin/pip install tox
   .venv/bin/tox -e all
   ```

4. [Pytest can drop you] in an interactive session in the case an error occurs.
   In order to do that you need to pass a `--pdb` option (for example by
   running `tox -- -k <NAME OF THE FALLING TEST> --pdb`).
   You can also setup breakpoints manually instead of using the `--pdb` option.

## Maintainer tasks

### Releases

```{todo} This section assumes you are using PyPI to publicly release your package.

   If instead you are using a different/private package index, please update
   the instructions accordingly.
```

If you are part of the group of maintainers and have correct user permissions
on [PyPI], the following steps can be used to release a new version for
`maskilayer`:

1. Make sure all unit tests are successful.
2. Tag the current commit on the main branch with a release tag, e.g., `v1.2.3`.
3. Push the new tag to the upstream [repository],
   e.g., `git push upstream v1.2.3`
4. Clean up the `dist` and `build` folders with `tox -e clean`
   (or `rm -rf dist build`)
   to avoid confusion with old builds and Sphinx docs.
5. Run `tox -e build` and check that the files in `dist` have
   the correct version (no `.dirty` or [git] hash) according to the [git] tag.
   Also check the sizes of the distributions, if they are too big (e.g., >
   500KB), unwanted clutter may have been accidentally included.
6. Run `tox -e publish -- --repository pypi` and check that everything was
   uploaded to [PyPI] correctly.

[^contrib1]: Even though, these resources focus on open source projects and
    communities, the general ideas behind collaborating with other developers
    to collectively create software are general and can be applied to all sorts
    of environments, including private companies and proprietary code bases.


[black]: https://pypi.org/project/black/
[commonmark]: https://commonmark.org/
[contribution-guide.org]: http://www.contribution-guide.org/
[creating a pr]: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request
[descriptive commit message]: https://chris.beams.io/posts/git-commit
[docstrings]: https://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html
[first-contributions tutorial]: https://github.com/firstcontributions/first-contributions
[flake8]: https://flake8.pycqa.org/en/stable/
[git]: https://git-scm.com
[github web interface]: https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository
[github's code editor]: https://docs.github.com/en/github/managing-files-in-a-repository/managing-files-on-github/editing-files-in-your-repository
[github's fork and pull request workflow]: https://guides.github.com/activities/forking/
[guide created by freecodecamp]: https://github.com/freecodecamp/how-to-contribute-to-open-source
[miniconda]: https://docs.conda.io/en/latest/miniconda.html
[myst]: https://myst-parser.readthedocs.io/en/latest/syntax/syntax.html
[other kinds of contributions]: https://opensource.guide/how-to-contribute
[pre-commit]: https://pre-commit.com/
[pypi]: https://pypi.org/
[pyscaffold's contributor's guide]: https://pyscaffold.org/en/stable/contributing.html
[pytest can drop you]: https://docs.pytest.org/en/stable/usage.html#dropping-to-pdb-python-debugger-at-the-start-of-a-test
[python software foundation's code of conduct]: https://www.python.org/psf/conduct/
[restructuredtext]: https://www.sphinx-doc.org/en/master/usage/restructuredtext/
[sphinx]: https://www.sphinx-doc.org/en/master/
[tox]: https://tox.readthedocs.io/en/stable/
[virtual environment]: https://realpython.com/python-virtual-environments-a-primer/
[virtualenv]: https://virtualenv.pypa.io/en/stable/


```{todo} Please review and change the following definitions:
```

[repository]: https://github.com/<USERNAME>/maskilayer
[issue tracker]: https://github.com/<USERNAME>/maskilayer/issues
</file>

<file path="LICENSE.txt">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "{}"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright {yyyy} {name of copyright owner}

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="pyproject.toml">
[build-system]
# AVOID CHANGING REQUIRES: IT WILL BE UPDATED BY PYSCAFFOLD!
requires = ["setuptools>=46.1.0", "setuptools_scm[toml]>=5"]
build-backend = "setuptools.build_meta"

[tool.setuptools_scm]
# For smarter version schemes and other configuration options,
# check out https://github.com/pypa/setuptools_scm
version_scheme = "no-guess-dev"

[tool.black]
line-length = 88
target-version = ['py311']
include = '\.pyi?$'
extend-exclude = '''
/(
  # directories
  \.eggs
  | \.git
  | \.hg
  | \.mypy_cache
  | \.tox
  | \.venv
  | build
  | dist
)/
'''

[tool.isort]
profile = "black"
line_length = 88
known_first_party = ["maskilayer"]
</file>

<file path="README.md">
# maskilayer

`maskilayer` is a Python tool for compositing two images using one or more mask images.

- Composite two images (background + overlay) using one or more mask images
- Supply positive masks (overlay is preferred in bright areas of the mask) or negative masks (overlay is preferred in dark mask areas)
- Normalize masks with adjustable levels (0-5)

## 1. Installation

Install `maskilayer` using pip:

```bash
pip install --upgrade maskilayer
```

or the development version in a specific Python:

```bash
python3.11 -m pip install --upgrade git+https://github.com/twardoch/maskilayer
```

## 2. Rationale

### 2.1. Selective image sharpening

Combine a sharpened image with its original version using a segmentation mask:

1. Process an original image with an automatic sharpening method.
2. Use a segmentation model to generate a segmentation mask that isolates a specific subject.
3. Use `maskilayer` to composite:
   - background: original image
   - overlay: sharpened version
   - mask: segmentation mask

`maskilayer` will save a result, which will be a composite image where only the subject is sharpened, while the rest remains as in the original.

### 2.2. Creative upscaling with depth based compositing

Blend two differently upscaled versions of an image using a depth mask:

1. Upscale an image using a conservative upscaler like [Codeformer](https://replicate.com/sczhou/codeformer) to get predictable details for the background areas of the image. Supply the conservative upscale as background to `maskilayer`.
2. Upscale the same image using a creative upscaler like [Ultimate SD Upscale](https://replicate.com/fewjative/ultimate-sd-upscale) to get additional details for foreground (subject) areas of the image. Supply the creative upscale as overlay (compositing image) to `maskilayer`.
3. Generate a depth mask using [Depth Anything](https://replicate.com/cjwbw/depth-anything) or [Midas](https://replicate.com/cjwbw/midas) (where the far areas are dark, and the close areas are bright). Supply the result as the (positive) mask to `maskilayer`. Or use a model like [Marigold](https://replicate.com/adirik/marigold) (where the close subjects are dark), and supply the resulting mask as inverted (negative) mask.
4. Use `maskilayer` to composite:
   - background: conservative upscale
   - overlay: creative upscale
   - mask: depth mask (inverted mask if close areas are dark)

`maskilayer` will save a result, which will be a composite image with creative details for close subjects, and more conservative rendering for distant areas.

## 3. Usage

### 3.1. Command Line Interface

#### 3.1.1. Basic usage

```bash
maskilayer -b background.png -c overlay.png -o output.png
```

#### 3.1.2. Selective image sharpening example

```bash
maskilayer --back original.png --comp sharpened.png --out sharpened_subject.png --masks segmentation_mask.png --norm 3 --verbose
```

#### 3.1.3. Creative upscaling with depth based compositing example

```bash
maskilayer --back conservative_upscale.png --comp creative_upscale.png --out composite_upscale.png --masks "depth_mask1.png;depth_mask2.png" --imasks "inverted_depth_mask3.png" --norm 2 --verbose
```

#### 3.1.4. CLI documentation

```text
NAME
    maskilayer - Composite two images using mask(s).

SYNOPSIS
    maskilayer <flags>

DESCRIPTION
    Composite two images using mask(s).

FLAGS
    -b, --back=BACK
        Type: str
        Default: ''
        layer 0 (background image path)
    -c, --comp=COMP
        Type: str
        Default: ''
        layer 1 (overlay image path that will be composited via masks)
    -o, --out=OUT
        Type: str
        Default: ''
        output composite image
    -s, --smask=SMASK
        Type: str
        Default: ''
        path to save the final mask (optional)
    -m, --masks=MASKS
        Type: Optional
        Default: None
        ;-separated mask image paths (optional)
    -i, --imasks=IMASKS
        Type: Optional
        Default: None
        ;-separated negative mask image paths (optional)
    -n, --norm=NORM
        Type: int
        Default: 0
        perform mask normalization with level 0-5
    -v, --verbose=VERBOSE
        Type: bool
        Default: False
        print additional output
    -f, --fast=FAST
        Type: bool
        Default: False
        save fast but larger files
```

### 3.2. Python API

#### 3.2.1. Basic usage

```python
from pathlib import Path
from maskilayer import comp_images

comp_images(
    background=Path("background.png"),
    overlay=Path("overlay.png"),
    output=Path("output.png")
)
```

#### 3.2.2. Selective image sharpening example

```python
from pathlib import Path
from maskilayer import comp_images

comp_images(
    background=Path("original.png"),
    overlay=Path("sharpened.png"),
    output=Path("sharpened_subject.png"),
    masks=[Path("segmentation_mask.png")],
    normalize_level=3,
    verbose=True
)
```

#### 3.2.3. Creative upscaling with depth based compositing example

```python
from pathlib import Path
from maskilayer import comp_images

comp_images(
    background=Path("conservative_upscale.png"),
    overlay=Path("creative_upscale.png"),
    output=Path("composite_upscale.png"),
    masks=[Path("depth_mask1.png"), Path("depth_mask2.png")],
    invert_masks=[Path("inverted_depth_mask3.png")],
    normalize_level=2,
    verbose=True
)
```

## 4. Mask handling

- If you supply multiple masks, `maskilayer` averages them for the final composition.
- `maskilayer` always converts the mask images to grayscale.
- If you supply a normalization level, `maskilayer` will adjust the mask contrast:
  - Level 0 uses masks as-is
  - Level 1 stretches grayscale range to full black-white spectrum
  - Levels 2-5 progressively increase contrast for more abrupt transitions between bright and dark (level values higher than 5 are permitted but not supported)

### 4.1. Tips for handling multiple mask paths

#### 4.1.1. In CLI

- Use semicolons (`;`) to separate multiple mask paths (you also may use commas):
  ```bash
  maskilayer --masks mask1.png;mask2.png;mask3.png
  ```
- For inverted masks, use the `--imasks` flag:
  ```bash
  maskilayer --imasks inverted_mask1.png;inverted_mask2.png
  ```
- You can use both positive and negative masks in the same command:
  ```bash
  maskilayer --masks positive_mask.png --imasks negative_mask.png
  ```

#### 4.1.2. In Python

- Use lists to provide multiple mask paths:
  ```python
  masks=[Path("mask1.png"), Path("mask2.png"), Path("mask3.png")]
  ```
- For inverted masks, use the `invert_masks` parameter:
  ```python
  invert_masks=[Path("inverted_mask1.png"), Path("inverted_mask2.png")]
  ```
- You can use both positive and negative masks in the same function call:
  ```python
  comp_images(
      ...,
      masks=[Path("positive_mask.png")],
      invert_masks=[Path("negative_mask.png")]
  )
  ```

## 5. License

- Idea & Copyright (c) 2024 Adam Twardoch
- [Python code](https://github.com/twardoch/maskilayer) written with assistance from OpenAI GPT-4o and Anthropic Claude 3
- Licensed under the [Apache License 2.0](./LICENSE.txt)
</file>

<file path="setup.cfg">
[metadata]
name = maskilayer
description = Python tool to composite two images using multiple mask images
author = Adam Twardoch
author_email = adam+github@twardoch.com
license = Apache-2.0
license_files = LICENSE.txt
long_description = file: README.md
long_description_content_type = text/markdown; charset=UTF-8; variant=GFM
url = https://github.com/twardoch/maskilayer
project_urls =
    Source = https://github.com/twardoch/maskilayer
    Tracker = https://github.com/twardoch/maskilayer/issues

platforms = any

classifiers =
    Development Status :: 4 - Beta
    Intended Audience :: Developers
    License :: OSI Approved :: Apache Software License
    Operating System :: OS Independent
    Programming Language :: Python
    Programming Language :: Python :: 3
    Programming Language :: Python :: 3.11
    Topic :: Multimedia :: Graphics
    Topic :: Software Development :: Libraries :: Python Modules

[options]
zip_safe = False
packages = find_namespace:
include_package_data = True
package_dir =
    =src

python_requires = >=3.11

install_requires =
    numpy
    Pillow
    aiofiles
    fire
    rich

[options.packages.find]
where = src
exclude =
    tests

[options.extras_require]
testing =
    setuptools
    pytest
    pytest-cov

[options.entry_points]
console_scripts =
    maskilayer = maskilayer.__main__:cli

[tool:pytest]
addopts =
    --cov maskilayer --cov-report term-missing
    --verbose
norecursedirs =
    dist
    build
    .tox
testpaths = tests

[flake8]
max_line_length = 88
extend_ignore = E203, W503
exclude =
    .tox
    build
    dist
    .eggs
    docs/conf.py

[pyscaffold]
version = 4.5
package = maskilayer
extensions =
    github_actions
    markdown
    pre_commit
</file>

<file path="setup.py">
"""
    Setup file for maskilayer.
    Use setup.cfg to configure your project.

    This file was generated with PyScaffold 4.5.
    PyScaffold helps you to put up the scaffold of your new Python project.
    Learn more under: https://pyscaffold.org/
"""
from setuptools import setup

if __name__ == "__main__":
    try:
        setup(use_scm_version={"version_scheme": "no-guess-dev"})
    except:  # noqa
        print(
            "\n\nAn error occurred while building the project, "
            "please ensure you have the most updated version of setuptools, "
            "setuptools_scm and wheel with:\n"
            "   pip install -U setuptools setuptools_scm wheel\n\n"
        )
        raise
</file>

<file path="tox.ini">
# Tox configuration file
# Read more under https://tox.wiki/
# THIS SCRIPT IS SUPPOSED TO BE AN EXAMPLE. MODIFY IT ACCORDING TO YOUR NEEDS!

[tox]
minversion = 3.24
envlist = default
isolated_build = True


[testenv]
description = Invoke pytest to run automated tests
setenv =
    TOXINIDIR = {toxinidir}
passenv =
    HOME
    SETUPTOOLS_*
extras =
    testing
commands =
    pytest {posargs}


# # To run `tox -e lint` you need to make sure you have a
# # `.pre-commit-config.yaml` file. See https://pre-commit.com
# [testenv:lint]
# description = Perform static analysis and style checks
# skip_install = True
# deps = pre-commit
# passenv =
#     HOMEPATH
#     PROGRAMDATA
#     SETUPTOOLS_*
# commands =
#     pre-commit run --all-files {posargs:--show-diff-on-failure}


[testenv:{build,clean}]
description =
    build: Build the package in isolation according to PEP517, see https://github.com/pypa/build
    clean: Remove old distribution files and temporary build artifacts (./build and ./dist)
# https://setuptools.pypa.io/en/stable/build_meta.html#how-to-use-it
skip_install = True
changedir = {toxinidir}
deps =
    build: build[virtualenv]
passenv =
    SETUPTOOLS_*
commands =
    clean: python -c 'import shutil; [shutil.rmtree(p, True) for p in ("build", "dist", "docs/_build")]'
    clean: python -c 'import pathlib, shutil; [shutil.rmtree(p, True) for p in pathlib.Path("src").glob("*.egg-info")]'
    build: python -m build {posargs}
# By default, both `sdist` and `wheel` are built. If your sdist is too big or you don't want
# to make it available, consider running: `tox -e build -- --wheel`


[testenv:{docs,doctests,linkcheck}]
description =
    docs: Invoke sphinx-build to build the docs
    doctests: Invoke sphinx-build to run doctests
    linkcheck: Check for broken links in the documentation
passenv =
    SETUPTOOLS_*
setenv =
    DOCSDIR = {toxinidir}/docs
    BUILDDIR = {toxinidir}/docs/_build
    docs: BUILD = html
    doctests: BUILD = doctest
    linkcheck: BUILD = linkcheck
deps =
    -r {toxinidir}/docs/requirements.txt
    # ^  requirements.txt shared with Read The Docs
commands =
    sphinx-build --color -b {env:BUILD} -d "{env:BUILDDIR}/doctrees" "{env:DOCSDIR}" "{env:BUILDDIR}/{env:BUILD}" {posargs}


[testenv:publish]
description =
    Publish the package you have been developing to a package index server.
    By default, it uses testpypi. If you really want to publish your package
    to be publicly accessible in PyPI, use the `-- --repository pypi` option.
skip_install = True
changedir = {toxinidir}
passenv =
    # See: https://twine.readthedocs.io/en/latest/
    TWINE_USERNAME
    TWINE_PASSWORD
    TWINE_REPOSITORY
    TWINE_REPOSITORY_URL
deps = twine
commands =
    python -m twine check dist/*
    python -m twine upload {posargs:--repository {env:TWINE_REPOSITORY:testpypi}} dist/*
</file>

</files>
